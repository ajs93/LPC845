\hypertarget{Ejemplo_ADC_8c-example}{}\section{Ejemplo\+\_\+\+A\+D\+C.\+c}
Ejemplo sobre la utilización del {\itshape A\+D\+C.\+El} programa utiliza el clock por default con el que comienza el microcontrolador, es decir, el {\itshape Free Running Oscillator} funcionando a $ 12MHz $.

El periférico será configurado con las siguientes características\+:
\begin{DoxyItemize}
\item Funcionamiento {\bfseries sincrónico} 
\item Frecuencia de muestreo de $ 1Mhz $
\item Modo bajo consumo inhabilitado
\end{DoxyItemize}

La secuencia A es configurada para generar conversiones en los canales 0 y 8\+:
\begin{DoxyItemize}
\item El canal 0 está conectado al preset propio del stick de desarrollo (Puerto 0 pin 7)
\item El canal 8 está ubicado en el pin número 3 (Puerto 0 pin 18) y se le puede conectar un preset externo entre V\+DD y G\+ND.
\end{DoxyItemize}Además, la secuencia tendrá la siguiente configuración\+:
\begin{DoxyItemize}
\item Trigger\+: Únicamente se disparan conversiones por software
\item Bypass sincronismo\+: Sí
\item Modo de interrupción\+: Cuando termina la secuencia completa
\item Burst\+: Inhabilitado
\item Un trigger dispara\+: Una conversión de secuencia completa
\item Secuencia A como baja prioridad\+: No
\end{DoxyItemize}

Una vez inicializado el periférico, se configura el periférico {\itshape Systick} para interrumpir cada $ 1mseg $ y mediante su manejador se lleva la cuenta de los milisegundos transcurridos. Una vez transcurridos $ 1000mseg $, se dispara una conversión de {\itshape A\+DC}, y sus resultados se guardan en dos variables globales.

Ubicando un {\itshape breakpoint} adecuadamente, se pueden leer los resultados de las conversiones ya ubicadas en las variables globales.


\begin{DoxyCodeInclude}

\textcolor{preprocessor}{#include <cr\_section\_macros.h>}
\textcolor{preprocessor}{#include <stddef.h>}
\textcolor{preprocessor}{#include <\hyperlink{HAL__ADC_8h}{HAL\_ADC.h}>}
\textcolor{preprocessor}{#include <\hyperlink{HAL__SYSTICK_8h}{HAL\_SYSTICK.h}>}

\textcolor{comment}{/* Máscara de configuración de canales habilitados para la secuencia a configurar */}
\textcolor{preprocessor}{#define     ADC\_CHANNELS                ((1 << 0) | (1 << 8))}

\textcolor{comment}{/* Macro para definir el tiempo de interrupción del \(\backslash\)e Systick en \(\backslash\)b microsegundos */}
\textcolor{preprocessor}{#define     TICK\_TIME\_USEG              (1000)}

\textcolor{comment}{/* Frecuencia de muestreo a utilizar por el ADC */}
\textcolor{preprocessor}{#define     ADC\_SAMPLE\_FREQ             (1000000)}

\textcolor{preprocessor}{#define     ADC\_SEQUENCE                (HAL\_ADC\_SEQUENCE\_SEL\_A)}

\textcolor{comment}{/* Tiempo de disparo de conversiones de \(\backslash\)e ADC en \(\backslash\)b milisegundos */}
\textcolor{preprocessor}{#define     ADC\_CONVERSION\_TIME\_MSEG    (1000)}

\textcolor{keyword}{static} \textcolor{keywordtype}{void} adc\_callback(\textcolor{keywordtype}{void});

\textcolor{keyword}{static} \textcolor{keywordtype}{void} systick\_callback(\textcolor{keywordtype}{void});

\textcolor{keyword}{static} uint8\_t flag\_secuencia\_adc\_completada = 0; \textcolor{comment}{/* Flag para indicar finalización de secuencia de
       conversión de \(\backslash\)e ADC */}

\textcolor{comment}{/*}
\textcolor{comment}{ * Variables para guardar los resultados de la secuencia de conversión}
\textcolor{comment}{ */}
\textcolor{keyword}{static} \hyperlink{group__ADC_structhal__adc__sequence__result__t}{hal\_adc\_sequence\_result\_t} resultados\_conversion\_adc[2];

\textcolor{comment}{/* Configuración de la secuencia. Como no va a cambiar es declarada \(\backslash\)e const */}
\textcolor{keyword}{static} \textcolor{keyword}{const} \hyperlink{structhal__adc__sequence__config__t}{hal\_adc\_sequence\_config\_t} adc\_config =
\{
    .\hyperlink{structhal__adc__sequence__config__t_acebe3f0fdc69a72787ddd6b19870641b}{channels} = ADC\_CHANNELS,
    .trigger = \hyperlink{group__ADC_gga67fe859b54301579f1b1daef874514caaaf722f012bd0aa063b595333f9012a20}{HAL\_ADC\_TRIGGER\_SEL\_NONE},
    .trigger\_pol = \hyperlink{group__ADC_gga4c5aa9e0991c432640845d2aedb971b2a007c22a34504d8557d98704becf95dc8}{HAL\_ADC\_TRIGGER\_POL\_SEL\_NEGATIVE\_EDGE},
    .sync\_bypass = \hyperlink{group__ADC_gga8aa0efd767a9edc5a80b80c4061e0904a1cbf7646bbe7c32e3e21663fc5952d77}{HAL\_ADC\_SYNC\_SEL\_BYPASS\_SYNC},
    .mode = \hyperlink{group__ADC_ggaf4981172881d597ede49249ba04fcafeae73eff6d5c4ef7297d31a28e4a76e149}{HAL\_ADC\_INTERRUPT\_MODE\_EOS},
    .burst = 0,
    .single\_step = 0,
    .low\_priority = 0,
    .callback = adc\_callback
\};

\textcolor{comment}{/*}
\textcolor{comment}{ * @brief Punto de entrada del programa}
\textcolor{comment}{ * @return Nunca deberia terminar esta función}
\textcolor{comment}{ */}
\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{void})
\{
    \textcolor{comment}{// Inicialización del periférico en modo SINCRÓNICO}
    \hyperlink{group__ADC_ga952626700075b275e7766c0095e4ec36}{hal\_adc\_init\_sync\_mode}(ADC\_SAMPLE\_FREQ, 
      \hyperlink{group__ADC_ggaf1570443ca3570a7ae83b90307bbeccaaf92172fb70ce285c23631cb025b3cd52}{HAL\_ADC\_LOW\_POWER\_MODE\_DISABLED});

    \textcolor{comment}{// Configuración de la secuencia a utilizar}
    \hyperlink{group__ADC_gadcef726eaa85af74ade96c14f9a48feb}{hal\_adc\_config\_sequence}(ADC\_SEQUENCE, &adc\_config);

    \textcolor{comment}{// Inicialización del \(\backslash\)e Systick con el tiempo de tick adecuado}
    \hyperlink{HAL__SYSTICK_8h_a29eb17e59d26a3f1a1f9184154964f36}{hal\_systick\_init}(TICK\_TIME\_USEG, systick\_callback);

    \textcolor{keywordflow}{while}(1)
    \{
        \textcolor{keywordflow}{if}(flag\_secuencia\_adc\_completada == 1) \textcolor{comment}{// Esto o hacer "if(flag\_secuencia\_adc\_completada)" es
       indistinto}
        \{
            uint32\_t variable\_auxiliar;

            flag\_secuencia\_adc\_completada = 0;

            (void) variable\_auxiliar; \textcolor{comment}{// Esta línea es ideal para colocar el breakpoint!}
        \}
    \}

    \textcolor{keywordflow}{return} 0;
\}

\textcolor{comment}{/*}
\textcolor{comment}{ * @brief Callback a ejecutar en cada tick del \(\backslash\)e Systick}
\textcolor{comment}{ */}
\textcolor{keyword}{static} \textcolor{keywordtype}{void} systick\_callback(\textcolor{keywordtype}{void})
\{
    \textcolor{keyword}{static} uint32\_t contador\_disparo\_adc = 0;

    \textcolor{comment}{// Conteo con valor límite}
    contador\_disparo\_adc = (contador\_disparo\_adc + 1) % ADC\_CONVERSION\_TIME\_MSEG;

    \textcolor{keywordflow}{if}(contador\_disparo\_adc == 0) \textcolor{comment}{// Esto o hacer "if(!contador\_disparo\_adc)" es indistinto}
    \{
        \hyperlink{group__ADC_ga154950a81b5f589fde0139178ab1dcf3}{hal\_adc\_start\_sequence}(ADC\_SEQUENCE);
    \}
\}

\textcolor{comment}{/*}
\textcolor{comment}{ * @brief Callback a ejecutar en cada finalización de conversión de \(\backslash\)b secuencia de \(\backslash\)e ADC}
\textcolor{comment}{ */}
\textcolor{keyword}{static} \textcolor{keywordtype}{void} adc\_callback(\textcolor{keywordtype}{void})
\{
    \textcolor{comment}{// Obtención de resultados de conversión}
    \hyperlink{group__ADC_gaf58fbae95e4083bddf74495df7709674}{hal\_adc\_get\_sequence\_result}(ADC\_SEQUENCE, resultados\_conversion\_adc);

    flag\_secuencia\_adc\_completada = 1;
\}
\end{DoxyCodeInclude}
 