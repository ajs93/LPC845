/**
 * @file timer.c
 * @brief Funciones para el manejo de timers por software
 * @author Augusto Santini
 * @date 12/2019
 * @version 1.0
 */

#include <stdint.h>
#include <timer.h>

#define		MAX_TIMERS			15

typedef struct
{
	uint8_t running : 1;
	uint8_t repeat : 1;
	uint8_t timeouted : 1;
	uint32_t msecs;
	uint32_t msecs_to_live;
	void *callback(void);
}timer_t;

static timer_t timers[MAX_TIMERS];

/**
 * @brief Iniciar un timer
 * @param[in] event_number Numero de evento asociado
 * @param[in] msecs Tiempo (en milisegundos) del timer a vencer
 * @param[in] callback Callback a ejecutar una vez vencido el timer
 * @param[in] repeat Si es 0 es un timer one-shot, caso contrario es repetitivo
 */
void timer_start(uint8_t event_number, uint32_t msecs, void *callback(void), uint8_t repeat)
{
	timers[event_number].msecs = msecs;
	timers[event_number].msecs_to_live = msecs;
	timers[event_number].repeat = repeat;
	timers[event_number].callback = callback;

	if(msecs > 0)
	{
		timers[event_number].timeouted = 0;
		timers[event_number].running = 1;
	}
	else
	{
		timers[event_number].timeouted = 1;
		timers[event_number].running = 0;
	}
}

/**
 * @brief Funcion a ejecutar en el loop principal
 *
 * Esta funcion se encargara de llamar a los callbacks de los timers que hayan vencido
 */
void timer_loop(void)
{
	uint8_t counter;

	for(counter = 0; counter < MAX_TIMERS; counter++)
	{
		if(timers[counter].timeouted == 1)
		{
			timers[counter].timeouted = 0;
			timers[counter].callback();

			if(timers[counter].repeat == 1)
			{
				timers[counter].msecs_to_live = timers[counter].msecs;
			}
			else
			{
				timers[counter].running = 0;
			}
		}
	}
}

/**
 * @brief Callback para revisar la maquinaria de timers (a ejecutar cada 1mseg)
 */
void timer_check(void)
{

}
