/**
 * @file termometro.c
 * @brief Funciones para el manejo del termometro
 * @author Augusto Santini
 * @date 12/2019
 * @version 1.0
 */

#include <stdint.h>
#include <termometro.h>
#include <HPL_ADC.h>
#include <HPL_IOCON.h>

#define		ADC_SAMPLING_FREQUENCY			100000
#define		ADC_CHANNEL						1
#define		ADC_CHANNEL_MASK				(1 << ADC_CHANNEL)

#define		CONVERSION_PERIOD_MSEC			100

#define		CONVERSION_BUFFER_LENGTH		10

static uint32_t conversion_buffer[CONVERSION_BUFFER_LENGTH];
static uint32_t conversion_buffer_idx = 0;
static uint32_t current_temperature = 0;

static void adc_conversion_finished(void);

/**
 * @brief Inicializacion del termometro
 */
void termometro_init(void)
{
	ADC_conversions_config_t adc_config;

	adc_config.burst = 0;
	adc_config.channels = ADC_CHANNEL_MASK;
	adc_config.conversion_ended_callback = adc_int;

	ADC_init(ADC_SAMPLING_FREQUENCY);

	ADC_config_conversions(&adc_config);
}

/**
 * @brief Callback para revisar el termometro periodicamente
 */
void termometro_check(void)
{
	static uint32_t msec_counter = 0;

	msec_counter = (msec_counter + 1) % CONVERSION_PERIOD_MSEC;

	if(msec_counter == 0)
	{
		ADC_start_conversions();
	}
}

/**
 * @brief Callback a ejecutar una vez terminada una conversion de ADC
 */
static void adc_conversion_finished(void)
{
	uint32_t adc_value;

	if(ADC_get_conversion(ADC_CHANNEL, &adc_value) == ADC_GET_CONVERSION_SUCCESS)
	{
		conversion_buffer[conversion_buffer_idx] = adc_value;

		conversion_buffer_idx = (conversion_buffer_idx + 1) % CONVERSION_BUFFER_LENGTH;

		if(conversion_buffer_idx == 0)
		{

		}
	}
}
